use std::convert::TryInto;

use super::{MessageTraits, MessageType};

use super::information_elements::InformationElement;

pub struct Message {
    pub t_pdu: Vec<u8>
}

impl Message {
    pub fn new(packet: &[u8]) -> Result<Self, String> {

        if packet.len() > 0xFFFF {
            return Err(format!("Packet to large. Length = {}", packet.len()));
        }

        let mut m = Message {
            t_pdu: Vec::new()
        };
        
        m.t_pdu = Vec::new();
        
        for i in 0..packet.len()
        {
            m.t_pdu.push(packet[i]);
        }

        Ok(m)
    }

    pub fn parse(buffer: &[u8]) -> Option<(Self, usize)> {

        let m = Message::new(buffer);

        if let Ok(m) = m {
            let pos = m.t_pdu.len();
            Some((m, pos))
        }
        else
        {
            None
        }

        
    }
}

impl MessageTraits for Message {
    fn push_ie(&mut self, _ie: InformationElement)
    {
        ()
    }

    fn pop_ie(&mut self) -> Option<InformationElement>
    {
        None
    }

    fn message_type(&self) -> MessageType {
        MessageType::GPDU
    }

    fn length(&self) -> u16 {
        self.t_pdu.len().try_into().unwrap()
    }

    fn generate(&self, buffer: &mut[u8]) -> usize {
        for i in 0..self.t_pdu.len()
        {
            buffer[i] = self.t_pdu[i];
        }
        self.t_pdu.len()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::MTU;
    use crate::gtp_v1::packet::messages::{MessageType, MessageTraits}; 

    #[test]
    fn test_new() {
        let icmpv4 = [
            0x45, 0x00, 0x00, 0x54, 0xaf, 0x2a, 0x40, 0x00,
            0x3f, 0x01, 0xba, 0xcc, 0xc0, 0xa8, 0x00, 0xfa,
            0x08, 0x08, 0x08, 0x08, 
            0x08, 0x00, 0xa9, 0xfe, 0x03, 0xe9, 0x00, 0x01,
            0x5a, 0x5f, 0x33, 0x5f, 0x00, 0x00, 0x00, 0x00,
            0xfd, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
            0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
            0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
            0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37
        ];

        let m = Message::new(&icmpv4);
        
        if let Ok(_) = m {
            assert!(true)
        }
        else {
            //Could not create message
            assert!(false)
        }

        let too_big = [ 0; 0x1FFFF ];

        let m = Message::new(&too_big);
        
        if let Ok(_) = m {
            assert!(false)
        }
        else {
            // We have too big a packet. As a result attach_packet should fail
            assert!(true)
        }
    }

    #[test]
    fn test_generate() {
        let mut buffer = [0; MTU];

        let icmpv4 = [
            0x45, 0x00, 0x00, 0x54, 0xaf, 0x2a, 0x40, 0x00,
            0x3f, 0x01, 0xba, 0xcc, 0xc0, 0xa8, 0x00, 0xfa,
            0x08, 0x08, 0x08, 0x08, 
            0x08, 0x00, 0xa9, 0xfe, 0x03, 0xe9, 0x00, 0x01,
            0x5a, 0x5f, 0x33, 0x5f, 0x00, 0x00, 0x00, 0x00,
            0xfd, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
            0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
            0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
            0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37
        ];

        let m = Message::new(&icmpv4);
        
        if let Ok(m) = m {
            let pos = m.generate(&mut buffer);

            for i in 0..pos {
                if buffer[i] != icmpv4[i] {
                    println!("{} (actual) != {} (expected) at byte {}", buffer[i], icmpv4[i], i);
                    assert!(false);
                } 
            }
        }
        else {
            //Could not create message
            assert!(false)
        }
    }
    
    #[test]
    fn test_length() {
        let icmpv4 = [
            0x45, 0x00, 0x00, 0x54, 0xaf, 0x2a, 0x40, 0x00,
            0x3f, 0x01, 0xba, 0xcc, 0xc0, 0xa8, 0x00, 0xfa,
            0x08, 0x08, 0x08, 0x08, 
            0x08, 0x00, 0xa9, 0xfe, 0x03, 0xe9, 0x00, 0x01,
            0x5a, 0x5f, 0x33, 0x5f, 0x00, 0x00, 0x00, 0x00,
            0xfd, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
            0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
            0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
            0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37
        ];

        let m = Message::new(&icmpv4);
        
        if let Ok(m) = m {
            assert_eq!(m.length(), 84)
        }
        else {
            //Could not create message
            assert!(false)
        }
    }

    #[test]
    fn test_message_type() {
        let m = Message::new(&[]);
        
        if let Ok(m) = m {
            assert_eq!(m.message_type() as u8, MessageType::GPDU as u8);
        }
        else {
            assert!(false);
        }
    }

    #[test]
    fn test_message_parse() {
        let m_bytes = [
            0x45, 0x00, 0x00, 0x54, 0xaf, 0x2a, 0x40, 0x00,
            0x3f, 0x01, 0xba, 0xcc, 0xc0, 0xa8, 0x00, 0xfa,
            0x08, 0x08, 0x08, 0x08, 
            0x08, 0x00, 0xa9, 0xfe, 0x03, 0xe9, 0x00, 0x01,
            0x5a, 0x5f, 0x33, 0x5f, 0x00, 0x00, 0x00, 0x00,
            0xfd, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
            0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
            0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
            0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37
        ];

        let m = Message::parse(&m_bytes);

        if let Some((m, pos)) = m {
            assert_eq!(m_bytes.len(), pos);
            for i in 0..m_bytes.len() {
                if m.t_pdu[i] != m_bytes[i] {
                    println!("{} (actual) != {} (expected) at byte {}", m.t_pdu[i], m_bytes[i], i);
                    assert!(false);
                } 
            }
        }
        else {
            // Failed to parse message
            assert!(false);
        }
    }
}
